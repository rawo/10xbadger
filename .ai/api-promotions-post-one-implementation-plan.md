# API Endpoint Implementation Plan: POST /api/promotions

## 1. Endpoint Overview

This endpoint creates a new promotion in draft status based on a specified promotion template. The promotion serves as a container for collecting accepted badge applications that meet template requirements for career advancement. Upon creation, the promotion copies key template fields (path, levels) for denormalized fast queries and associates with the authenticated user as creator.

**Key Features**:
- Create promotion in draft status
- Reference an active promotion template
- Copy template metadata (path, from_level, to_level) for performance
- Associate with current authenticated user
- Validate template existence and active status
- Return created promotion with all fields

**Business Context**:
This endpoint is used for:
- Starting a new promotion application process
- Initiating the badge collection workflow
- Associating user with specific career path and level progression
- Foundation for subsequent badge assignment operations

**Key Business Rules**:
- Template must exist and be active (is_active = true)
- Status is always set to 'draft' on creation
- Creator is always current authenticated user (cannot be overridden)
- Template fields (path, from_level, to_level) are copied for query performance
- Future: Validate user's current level matches template's from_level

## 2. Request Details

- **HTTP Method**: POST
- **URL Structure**: `/api/promotions`
- **Authentication**: Required (ignored for development per instructions)
- **Authorization**: Authenticated users can create promotions for themselves

### Request Body

#### Required Fields

| Field | Type | Validation | Description |
|-------|------|------------|-------------|
| `template_id` | string (UUID) | Valid UUID format, must exist, must be active | ID of promotion template to use |

#### Request Body Schema (Zod)

```typescript
const createPromotionSchema = z.object({
  template_id: z.string().uuid("Invalid template ID format"),
});
```

### Request Examples

**Valid Request**:
```json
{
  "template_id": "750e8400-e29b-41d4-a716-446655440020"
}
```

**Invalid UUID Format**:
```json
{
  "template_id": "invalid-uuid"
}
```
Expected: 400 Bad Request with validation error

**Missing Required Field**:
```json
{}
```
Expected: 400 Bad Request with validation error

**Template Not Found**:
```json
{
  "template_id": "750e8400-0000-0000-0000-000000000000"
}
```
Expected: 404 Not Found

## 3. Used Types

### From `src/types.ts`

**Command Model**:
```typescript
interface CreatePromotionCommand {
  template_id: string;
}
```
*Defined at: src/types.ts:354-359*

**Response Types**:
- `PromotionRow` - Database row type from Supabase
  - Contains all promotion fields
  - Generated from Supabase schema

**Database Types**:
```typescript
export type PromotionRow = Tables<"promotions">;
export type PromotionTemplateRow = Tables<"promotion_templates">;
```

**Error Types**:
```typescript
interface ApiError {
  error: string;
  message: string;
  details?: ValidationErrorDetail[] | Record<string, unknown>;
}

interface ValidationErrorDetail {
  field: string;
  message: string;
}
```

### Validation Schema

```typescript
import { z } from "zod";

const createPromotionSchema = z.object({
  template_id: z.string().uuid("Invalid template ID format"),
});

type CreatePromotionInput = z.infer<typeof createPromotionSchema>;
```

## 4. Response Details

### Success Response (201 Created)

```json
{
  "id": "850e8400-e29b-41d4-a716-446655440030",
  "template_id": "750e8400-e29b-41d4-a716-446655440020",
  "created_by": "550e8400-e29b-41d4-a716-446655440000",
  "path": "technical",
  "from_level": "S1",
  "to_level": "S2",
  "status": "draft",
  "created_at": "2025-01-22T18:00:00Z",
  "submitted_at": null,
  "approved_at": null,
  "approved_by": null,
  "rejected_at": null,
  "rejected_by": null,
  "reject_reason": null,
  "executed": false
}
```

**Response Field Descriptions**:
- `id`: UUID of created promotion (generated by database)
- `template_id`: Reference to promotion template
- `created_by`: UUID of user who created promotion (from auth session)
- `path`: Career path copied from template ("technical", "financial", "management")
- `from_level`: Source level copied from template (e.g., "S1")
- `to_level`: Target level copied from template (e.g., "S2")
- `status`: Always "draft" for new promotions
- `created_at`: Timestamp when promotion was created
- `submitted_at`: null (not yet submitted)
- `approved_at`: null (not yet approved)
- `approved_by`: null (no reviewer yet)
- `rejected_at`: null (not rejected)
- `rejected_by`: null (no rejecting admin)
- `reject_reason`: null (no rejection reason)
- `executed`: false (promotion not executed)

### Error Responses

#### 400 Bad Request - Validation Error

**Missing Required Field**:
```json
{
  "error": "validation_error",
  "message": "Validation failed",
  "details": [
    {
      "field": "template_id",
      "message": "Required"
    }
  ]
}
```

**Invalid UUID Format**:
```json
{
  "error": "validation_error",
  "message": "Validation failed",
  "details": [
    {
      "field": "template_id",
      "message": "Invalid template ID format"
    }
  ]
}
```

**Empty Request Body**:
```json
{
  "error": "validation_error",
  "message": "Request body is required"
}
```

#### 401 Unauthorized (when auth enabled)

```json
{
  "error": "unauthorized",
  "message": "Authentication required"
}
```

#### 404 Not Found - Template Not Found or Inactive

```json
{
  "error": "not_found",
  "message": "Promotion template not found"
}
```

**Note**: Same response for both non-existent templates AND inactive templates to avoid information disclosure.

#### 500 Internal Server Error

```json
{
  "error": "internal_error",
  "message": "Failed to create promotion"
}
```

## 5. Data Flow

```
┌─────────────┐
│   Client    │
└──────┬──────┘
       │ POST /api/promotions
       │ Body: { template_id: "750e8400..." }
       ▼
┌─────────────────────────────────────────────────────┐
│           Astro API Route Handler                   │
│       src/pages/api/promotions/index.ts             │
│                                                      │
│  1. Parse request body                              │
│  2. Validate with Zod schema                        │
│  3. (Future) Get user from auth session             │
│  4. Extract userId for created_by                   │
└──────┬──────────────────────────────────────────────┘
       │ CreatePromotionCommand
       ▼
┌─────────────────────────────────────────────────────┐
│              PromotionService                       │
│        src/lib/promotion.service.ts                 │
│                                                      │
│  createPromotion(command, userId)                   │
│  1. Fetch template by ID                            │
│  2. Check if template exists                        │
│  3. Check if template is active                     │
│  4. If not found/inactive: throw error              │
│  5. Create promotion record:                        │
│     - template_id from command                      │
│     - created_by = userId                           │
│     - Copy path, from_level, to_level from template │
│     - status = 'draft'                              │
│  6. Return created promotion                        │
└──────┬──────────────────────────────────────────────┘
       │
       ▼
┌─────────────────────────────────────────────────────┐
│              Supabase Client                        │
│                                                      │
│  Transaction:                                       │
│  1. SELECT from promotion_templates                 │
│     WHERE id = $1 AND is_active = true              │
│                                                      │
│  2. INSERT into promotions                          │
│     (template_id, created_by, path,                 │
│      from_level, to_level, status)                  │
│     VALUES ($1, $2, $3, $4, $5, 'draft')            │
│     RETURNING *                                     │
└──────┬──────────────────────────────────────────────┘
       │
       ▼
┌─────────────────────────────────────────────────────┐
│            PostgreSQL Database                      │
│                                                      │
│  Tables:                                            │
│  - promotion_templates (validate existence/active)  │
│  - promotions (insert new record)                   │
│                                                      │
│  Constraints:                                       │
│  - promotions.template_id FK to promotion_templates │
│  - promotions.created_by FK to users                │
│  - promotions.status CHECK ('draft', 'submitted'...)│
└──────┬──────────────────────────────────────────────┘
       │
       ▼ Created promotion
┌─────────────────────────────────────────────────────┐
│           API Route Handler                         │
│                                                      │
│  1. Receive created promotion from service          │
│  2. Return 201 Created with promotion object        │
│  3. Set Location header (optional)                  │
└──────┬──────────────────────────────────────────────┘
       │
       ▼
┌─────────────┐
│   Client    │
└─────────────┘
```

## 6. Security Considerations

### Authentication

- **Requirement**: User must be authenticated via session
- **Implementation**: Ignored for development per instructions
- **Production**: Will check `context.locals.supabase.auth.getUser()`
- **Failure Response**: 401 Unauthorized if no valid session

### Authorization

- **Creator Enforcement**:
  - `created_by` is ALWAYS set to `current_user.id`
  - User cannot create promotions for other users
  - Field is not accepted in request body (ignored if present)
  - Server-side enforcement prevents privilege escalation

- **Template Access**:
  - All authenticated users can reference any active template
  - Templates are not user-specific (public catalog)
  - No special authorization check needed

### Input Validation

- **Request Body Validation**:
  - Use Zod schema to validate structure
  - Reject missing required fields with 400
  - Reject extra fields (strict mode)

- **UUID Format Validation**:
  - Use Zod UUID validator
  - Rejects invalid UUID formats with 400
  - Prevents SQL injection attempts
  - Example: `z.string().uuid()`

- **Template Validation**:
  - Verify template exists in database
  - Verify template is active (is_active = true)
  - Return 404 for both cases (don't distinguish)

### Data Exposure

- **Prevent Information Leakage**:
  - Don't expose internal error details to client
  - Log detailed errors server-side only
  - Return generic error messages for 500 errors
  - Return 404 (not 403) for inactive templates

- **Sensitive Data**:
  - No sensitive data in response (all fields are safe)
  - User can only see promotions they created
  - created_by field is expected and safe to expose

### SQL Injection Prevention

- **Mitigation**:
  - Use Supabase query builder exclusively (parameterized queries)
  - UUID validation prevents injection attempts
  - No string concatenation in queries
  - Supabase client handles query escaping automatically

### OWASP Top 10 Considerations

1. **A01:2021 - Broken Access Control**:
   - Mitigated by forcing created_by = current_user.id
   - Cannot create promotions for other users
   - Authentication prevents anonymous creation

2. **A03:2021 - Injection**:
   - Mitigated by using ORM/query builder and UUID validation
   - Parameterized queries prevent SQL injection
   - Zod validation prevents malformed input

3. **A05:2021 - Security Misconfiguration**:
   - Follow Astro/Supabase security best practices
   - Return generic error messages
   - No debug information in production responses

4. **A07:2021 - Identification and Authentication Failures**:
   - Handled by Supabase auth (when enabled)
   - Session-based authentication
   - No password handling in this endpoint

5. **Information Disclosure**:
   - Return 404 for both "not found" and "inactive" templates
   - Don't reveal which templates exist or their status
   - Generic error messages prevent enumeration

### Additional Security Measures

- **UUID Enumeration**: Not a concern (template IDs are public)
- **Rate Limiting**: Consider at infrastructure level (future)
- **Request Size Limits**: Handled by Astro framework
- **CORS**: Configure appropriately for frontend domain

## 7. Error Handling

### Error Scenarios

| Scenario | Status Code | Error Code | Handling Strategy |
|----------|-------------|------------|-------------------|
| Missing request body | 400 | `validation_error` | Check body exists before parsing |
| Empty request body | 400 | `validation_error` | Validate with Zod |
| Missing template_id | 400 | `validation_error` | Validate with Zod, return field-level error |
| Invalid UUID format | 400 | `validation_error` | Validate with Zod UUID schema |
| Extra fields in body | 400 | `validation_error` | Use Zod strict mode |
| Not authenticated | 401 | `unauthorized` | Check auth session (when enabled) |
| Template not found | 404 | `not_found` | Check service response |
| Template not active | 404 | `not_found` | Treat same as not found |
| Foreign key violation | 500 | `internal_error` | Catch DB error, log, return generic message |
| Database connection error | 500 | `internal_error` | Log error, return generic message |
| Unexpected exception | 500 | `internal_error` | Catch all, log, return generic message |

### Error Handling Strategy

1. **Validation Errors (400)**:
   - Parse request body with error handling
   - Validate with Zod schema
   - Return structured error response with field-level details
   - Include helpful message for developers
   - Don't proceed to service if validation fails

2. **Authentication Errors (401)**:
   - Check user session via Supabase auth (when enabled)
   - Return early if not authenticated
   - Clear error message: "Authentication required"
   - Don't expose any business logic

3. **Template Not Found/Inactive (404)**:
   - Service throws specific error for not found
   - Service throws specific error for inactive
   - Route handler catches both
   - Return same 404 response for both cases
   - Message: "Promotion template not found"
   - Don't distinguish between not found and inactive

4. **Database Errors (500)**:
   - Catch all database exceptions in service layer
   - Log full error details server-side (console.error with context)
   - Return generic error message to client
   - Don't expose database structure or query details
   - Include template_id in logs for debugging

5. **Unexpected Errors (500)**:
   - Wrap entire handler in try-catch
   - Log unexpected errors with full stack trace
   - Return generic error message
   - Consider alerting for production errors

### Error Response Format

All errors follow this structure:
```typescript
{
  error: string;           // Machine-readable error code
  message: string;         // Human-readable error message
  details?: Array<{        // Optional validation details
    field: string;
    message: string;
  }> | Record<string, unknown>;
}
```

### Custom Error Classes (Optional)

Consider creating custom error classes in service layer:
```typescript
class TemplateNotFoundError extends Error {
  constructor(templateId: string) {
    super(`Template ${templateId} not found or inactive`);
    this.name = 'TemplateNotFoundError';
  }
}
```

Benefits: Type-safe error handling, clearer intent, easier testing

## 8. Performance Considerations

### Potential Bottlenecks

1. **Template Validation Query**: Extra SELECT before INSERT
2. **Database Round Trips**: Two queries (SELECT + INSERT)
3. **Network Latency**: Client to server to database
4. **Foreign Key Checks**: Database validates FK constraints

### Optimization Strategies

1. **Combine Queries** (Future Optimization):
   - Use PostgreSQL function or trigger to validate template in single query
   - Example: Custom INSERT function that checks template first
   - Reduces round trips from 2 to 1
   - Trade-off: More complex database logic

2. **Database Optimization**:
   - **Indexes Required** (should already exist):
     - `promotion_templates(id)` - Primary key (indexed)
     - `promotion_templates(is_active)` - For active filter
     - `promotions(template_id)` - Foreign key (indexed)
     - `promotions(created_by)` - Foreign key (indexed)
     - `promotions(created_at)` - For sorting

   - **Query Pattern**:
     ```sql
     -- Template validation
     SELECT id, path, from_level, to_level, is_active
     FROM promotion_templates
     WHERE id = $1 AND is_active = true;

     -- Promotion creation
     INSERT INTO promotions (template_id, created_by, path, from_level, to_level, status)
     VALUES ($1, $2, $3, $4, $5, 'draft')
     RETURNING *;
     ```

3. **Caching** (Future Enhancement):
   - Cache active templates in Redis/memory
   - Cache key: `promotion_template:${id}:active`
   - TTL: 5-10 minutes
   - Invalidate on template update
   - Reduces template validation query
   - Trade-off: Cache invalidation complexity

4. **Response Size**:
   - Single promotion object is small (~1-2KB)
   - No nested objects or arrays
   - No compression needed
   - Fast serialization

5. **Denormalization Benefits**:
   - Copying path/levels to promotions table enables fast queries
   - Avoids JOIN in list/filter operations
   - Trade-off: Data duplication, but worth it for read performance

### Expected Performance

Based on indexed queries and simple INSERT:

- **Template Validation Query**: 5-10ms
- **Promotion Insert Query**: 5-15ms
- **Total Database Time**: 10-25ms
- **Serialization Time**: ~1ms
- **Total Response Time**: < 50ms (excluding network latency)
- **99th Percentile**: < 100ms

**Performance is excellent** - simple queries with proper indexes.

### Performance Monitoring

- Log slow requests (> 100ms) with template_id
- Track response times by user
- Monitor database query execution times
- Set up alerts for degraded performance (> 200ms)
- Track promotion creation rate

### Load Considerations

- Promotion creation is infrequent (users create 1-2 per year)
- Not a high-traffic endpoint
- No need for advanced optimization
- Current approach is sufficient for MVP

## 9. Implementation Steps

### Step 1: Update PromotionService

**File**: `src/lib/promotion.service.ts` (update existing file or create if doesn't exist)

**Purpose**: Add method to create a new promotion

```typescript
import type { SupabaseClient } from "@supabase/supabase-js";
import type { Database } from "@/db/database.types";
import type { CreatePromotionCommand, PromotionRow } from "@/types";

export class PromotionService {
  constructor(private supabase: SupabaseClient<Database>) {}

  /**
   * Creates a new promotion in draft status
   *
   * Validates that the template exists and is active, then creates a promotion
   * record with template metadata copied for denormalized queries.
   *
   * @param command - Promotion creation command with template_id
   * @param userId - Current authenticated user ID (promotion creator)
   * @returns Created promotion with all fields
   * @throws TemplateNotFoundError if template doesn't exist or is inactive
   * @throws Error if database operation fails
   */
  async createPromotion(
    command: CreatePromotionCommand,
    userId: string
  ): Promise<PromotionRow> {
    // Step 1: Validate template exists and is active
    const { data: template, error: templateError } = await this.supabase
      .from("promotion_templates")
      .select("id, path, from_level, to_level, is_active")
      .eq("id", command.template_id)
      .single();

    if (templateError || !template) {
      throw new Error(`Template not found: ${command.template_id}`);
    }

    if (!template.is_active) {
      throw new Error(`Template is not active: ${command.template_id}`);
    }

    // Step 2: Create promotion record
    const { data: promotion, error: createError } = await this.supabase
      .from("promotions")
      .insert({
        template_id: command.template_id,
        created_by: userId,
        path: template.path,
        from_level: template.from_level,
        to_level: template.to_level,
        status: "draft",
        executed: false,
      })
      .select()
      .single();

    if (createError) {
      throw new Error(`Failed to create promotion: ${createError.message}`);
    }

    if (!promotion) {
      throw new Error("Promotion creation returned no data");
    }

    return promotion as PromotionRow;
  }
}
```

**Key Points**:
- Validate template existence and active status first
- Throw clear errors for not found and inactive cases
- Copy template fields (path, from_level, to_level) for denormalization
- Force status = 'draft' and executed = false
- Use .select().single() to return created record
- Type assertion to PromotionRow for type safety

**Error Handling**:
- Template not found: Throw error with clear message
- Template inactive: Throw error (route handler treats same as not found)
- Database errors: Throw error with context

### Step 2: Create API Route Handler

**File**: `src/pages/api/promotions/index.ts` (new file)

**Purpose**: Handle HTTP request/response for promotion creation

```typescript
import type { APIRoute } from "astro";
import { PromotionService } from "@/lib/promotion.service";
import type { ApiError, CreatePromotionCommand } from "@/types";
import { z } from "zod";

// Request body validation schema
const createPromotionSchema = z.object({
  template_id: z.string().uuid("Invalid template ID format"),
});

/**
 * POST /api/promotions
 *
 * Creates a new promotion in draft status based on a promotion template.
 * Associates the promotion with the authenticated user as creator.
 *
 * ⚠️  DEVELOPMENT MODE: Authentication is currently DISABLED
 * TODO: Re-enable authentication before production deployment
 *
 * Request Body:
 * - template_id: UUID of promotion template (required)
 *
 * Development Mode Behavior:
 * - No authentication required
 * - Uses hardcoded test user ID
 *
 * Production Authorization (when enabled):
 * - Authenticated users can create promotions for themselves
 * - created_by is forced to current user ID (cannot be overridden)
 *
 * @returns 201 Created with promotion object
 * @returns 400 Bad Request if validation fails
 * @returns 401 Unauthorized if not authenticated (when auth enabled)
 * @returns 404 Not Found if template doesn't exist or is inactive
 * @returns 500 Internal Server Error on unexpected errors
 */
export const POST: APIRoute = async (context) => {
  try {
    // =========================================================================
    // DEVELOPMENT MODE: Authentication Disabled
    // =========================================================================
    // TODO: Re-enable authentication before production deployment
    // Authentication will be implemented later. For now, we use a test user ID.

    // =========================================================================
    // PRODUCTION CODE (Currently Disabled)
    // =========================================================================
    // Uncomment the code below when authentication is ready:
    /*
    // Step 1: Authentication Check
    const {
      data: { user },
      error: authError,
    } = await context.locals.supabase.auth.getUser();

    if (authError || !user) {
      const error: ApiError = {
        error: "unauthorized",
        message: "Authentication required",
      };
      return new Response(JSON.stringify(error), {
        status: 401,
        headers: { "Content-Type": "application/json" },
      });
    }

    const userId = user.id;
    */

    // Development mode: Use test user ID
    // TODO: Replace with actual user ID from auth session
    // For now, fetch first user from database for testing
    const { data: testUser, error: userError } = await context.locals.supabase
      .from("users")
      .select("id")
      .limit(1)
      .single();

    if (userError || !testUser) {
      const error: ApiError = {
        error: "internal_error",
        message: "Test user not found. Please ensure sample data is imported.",
      };
      return new Response(JSON.stringify(error), {
        status: 500,
        headers: { "Content-Type": "application/json" },
      });
    }

    const userId = testUser.id;

    // =========================================================================
    // Step 2: Parse and Validate Request Body
    // =========================================================================
    let requestBody: unknown;
    try {
      requestBody = await context.request.json();
    } catch {
      const error: ApiError = {
        error: "validation_error",
        message: "Request body is required and must be valid JSON",
      };
      return new Response(JSON.stringify(error), {
        status: 400,
        headers: { "Content-Type": "application/json" },
      });
    }

    const validation = createPromotionSchema.safeParse(requestBody);

    if (!validation.success) {
      const error: ApiError = {
        error: "validation_error",
        message: "Validation failed",
        details: validation.error.issues.map((err) => ({
          field: err.path.join("."),
          message: err.message,
        })),
      };
      return new Response(JSON.stringify(error), {
        status: 400,
        headers: { "Content-Type": "application/json" },
      });
    }

    const command: CreatePromotionCommand = validation.data;

    // =========================================================================
    // Step 3: Create Promotion via Service
    // =========================================================================
    const service = new PromotionService(context.locals.supabase);
    const promotion = await service.createPromotion(command, userId);

    // =========================================================================
    // Step 4: Return Success Response
    // =========================================================================
    return new Response(JSON.stringify(promotion), {
      status: 201,
      headers: {
        "Content-Type": "application/json",
        // Optional: Include Location header with URL to created resource
        // "Location": `/api/promotions/${promotion.id}`
      },
    });
  } catch (error) {
    // =========================================================================
    // Error Handling
    // =========================================================================
    // Log error for debugging (server-side only)
    // eslint-disable-next-line no-console
    console.error("Error in POST /api/promotions:", error);

    // Handle template not found (service throws error with "not found" message)
    if (
      error instanceof Error &&
      (error.message.includes("not found") ||
        error.message.includes("not active"))
    ) {
      const apiError: ApiError = {
        error: "not_found",
        message: "Promotion template not found",
      };
      return new Response(JSON.stringify(apiError), {
        status: 404,
        headers: { "Content-Type": "application/json" },
      });
    }

    // Return generic error to client (don't expose internal details)
    const apiError: ApiError = {
      error: "internal_error",
      message: "Failed to create promotion",
    };
    return new Response(JSON.stringify(apiError), {
      status: 500,
      headers: { "Content-Type": "application/json" },
    });
  }
};
```

**Key Points**:
- Parse request body with error handling
- Validate with Zod before calling service
- Use service layer for business logic
- Return 201 Created with created resource
- Map service errors to appropriate HTTP status codes
- Return 404 for both "not found" and "inactive" templates
- Authentication placeholder (disabled for development)

### Step 3: Manual Testing

**Prerequisites**:
- Supabase running locally: `npx supabase start`
- Development server running: `pnpm dev`
- Sample data imported (users, promotion templates)

**Test Scenarios**:

**1. Create Valid Promotion**:
```bash
# Get an active template ID first
curl -s 'http://localhost:3000/api/promotion-templates?is_active=true' | python3 -m json.tool

# Use a template ID from the response
curl -X POST 'http://localhost:3000/api/promotions' \
  -H 'Content-Type: application/json' \
  -d '{
    "template_id": "750e8400-e29b-41d4-a716-446655440020"
  }'
```
**Expected**: 201 Created with promotion object, status = "draft"

**2. Missing Request Body**:
```bash
curl -X POST 'http://localhost:3000/api/promotions' \
  -H 'Content-Type: application/json'
```
**Expected**: 400 Bad Request with validation error

**3. Missing template_id**:
```bash
curl -X POST 'http://localhost:3000/api/promotions' \
  -H 'Content-Type: application/json' \
  -d '{}'
```
**Expected**: 400 Bad Request with field-level error

**4. Invalid UUID Format**:
```bash
curl -X POST 'http://localhost:3000/api/promotions' \
  -H 'Content-Type: application/json' \
  -d '{
    "template_id": "invalid-uuid"
  }'
```
**Expected**: 400 Bad Request with "Invalid template ID format"

**5. Template Not Found (Valid UUID)**:
```bash
curl -X POST 'http://localhost:3000/api/promotions' \
  -H 'Content-Type: application/json' \
  -d '{
    "template_id": "750e8400-0000-0000-0000-000000000000"
  }'
```
**Expected**: 404 Not Found with "Promotion template not found"

**6. Verify Response Structure**:
```bash
curl -s -X POST 'http://localhost:3000/api/promotions' \
  -H 'Content-Type: application/json' \
  -d '{
    "template_id": "750e8400-e29b-41d4-a716-446655440020"
  }' | python3 -m json.tool
```
**Expected**:
- All promotion fields present
- status = "draft"
- executed = false
- created_by = test user ID
- path, from_level, to_level copied from template
- Timestamps populated

**7. Verify Template Fields Copied**:
```bash
# Create promotion and extract template_id
TEMPLATE_ID="750e8400-e29b-41d4-a716-446655440020"

# Get template details
curl -s "http://localhost:3000/api/promotion-templates/$TEMPLATE_ID" | \
  python3 -c "import json,sys; t=json.load(sys.stdin); print(f\"Template: path={t['path']}, from={t['from_level']}, to={t['to_level']}\")"

# Create promotion
curl -s -X POST 'http://localhost:3000/api/promotions' \
  -H 'Content-Type: application/json' \
  -d "{\"template_id\": \"$TEMPLATE_ID\"}" | \
  python3 -c "import json,sys; p=json.load(sys.stdin); print(f\"Promotion: path={p['path']}, from={p['from_level']}, to={p['to_level']}\")"
```
**Expected**: Promotion fields match template fields

**8. Test with Inactive Template** (if you have one):
```bash
# First, deactivate a template (as admin)
curl -s -X POST 'http://localhost:3000/api/promotion-templates/[template-id]/deactivate'

# Try to create promotion with inactive template
curl -X POST 'http://localhost:3000/api/promotions' \
  -H 'Content-Type: application/json' \
  -d '{
    "template_id": "[same-template-id]"
  }'
```
**Expected**: 404 Not Found (same response as non-existent template)

**9. Verify Database Record**:
```bash
# Create promotion and extract ID
PROMOTION_ID=$(curl -s -X POST 'http://localhost:3000/api/promotions' \
  -H 'Content-Type: application/json' \
  -d '{"template_id": "750e8400-e29b-41d4-a716-446655440020"}' | \
  python3 -c "import json,sys; print(json.load(sys.stdin)['id'])")

# Query database directly
psql postgresql://postgres:postgres@localhost:54322/postgres \
  -c "SELECT id, status, path, from_level, to_level, created_by FROM promotions WHERE id = '$PROMOTION_ID';"
```
**Expected**: Record exists with correct values

### Step 4: Integration Tests

**File**: `src/pages/api/__tests__/promotions.post.endpoint.spec.ts` (new file, when test framework available)

```typescript
import { describe, it, expect, beforeEach, afterEach } from 'vitest';

describe('POST /api/promotions', () => {
  let testUserId: string;
  let testTemplateId: string;

  beforeEach(async () => {
    // Setup test data
    // Create test user and active template
  });

  afterEach(async () => {
    // Cleanup test data
    // Delete created promotions, templates, users
  });

  describe('Success Cases', () => {
    it('creates promotion with valid template_id', async () => {
      // Test with valid active template
      // Expected: 201 Created with promotion object
    });

    it('returns promotion with status = draft', async () => {
      // Verify status field
      // Expected: status === "draft"
    });

    it('sets created_by to current user ID', async () => {
      // Verify created_by field
      // Expected: created_by === userId
    });

    it('copies path from template', async () => {
      // Verify path field matches template
      // Expected: promotion.path === template.path
    });

    it('copies from_level and to_level from template', async () => {
      // Verify level fields match template
      // Expected: levels match
    });

    it('sets executed to false', async () => {
      // Verify executed field
      // Expected: executed === false
    });

    it('sets all nullable fields to null', async () => {
      // Verify submitted_at, approved_at, etc. are null
      // Expected: All workflow fields null
    });

    it('returns all required promotion fields', async () => {
      // Verify response structure
      // Expected: All PromotionRow fields present
    });
  });

  describe('Validation Errors', () => {
    it('returns 400 for missing request body', async () => {
      // Test with no body
      // Expected: 400 with validation error
    });

    it('returns 400 for empty request body', async () => {
      // Test with {}
      // Expected: 400 with field-level error
    });

    it('returns 400 for missing template_id', async () => {
      // Test with other fields but no template_id
      // Expected: 400 with "template_id required" error
    });

    it('returns 400 for invalid UUID format', async () => {
      // Test with template_id: "invalid-uuid"
      // Expected: 400 with "Invalid template ID format"
    });

    it('returns 400 for non-string template_id', async () => {
      // Test with template_id: 123
      // Expected: 400 with validation error
    });

    it('ignores extra fields in request body', async () => {
      // Test with extra fields (strict mode)
      // Expected: 400 or fields ignored
    });
  });

  describe('Not Found Cases', () => {
    it('returns 404 for non-existent template', async () => {
      // Test with valid UUID that doesn't exist
      // Expected: 404 Not Found
    });

    it('returns 404 for inactive template', async () => {
      // Test with inactive template
      // Expected: 404 Not Found (same as non-existent)
    });

    it('does not distinguish between not found and inactive', async () => {
      // Test error messages are identical
      // Expected: Same error response
    });
  });

  describe('Authorization (when enabled)', () => {
    it('returns 401 when not authenticated', async () => {
      // Test without auth session
      // Expected: 401 Unauthorized
    });

    it('creates promotion for current user only', async () => {
      // Test created_by is forced to current user
      // Expected: created_by === current user ID
    });
  });

  describe('Database Constraints', () => {
    it('enforces foreign key constraint on template_id', async () => {
      // Test with deleted template (if possible)
      // Expected: 500 or 404 depending on implementation
    });

    it('enforces status CHECK constraint', async () => {
      // This is prevented by schema, just verify
      // Expected: status is always "draft"
    });
  });

  describe('Error Handling', () => {
    it('returns 500 for database connection errors', async () => {
      // Mock database connection failure
      // Expected: 500 with generic error message
    });

    it('does not expose internal error details', async () => {
      // Mock internal error
      // Expected: Generic error message, no stack trace
    });

    it('logs errors server-side', async () => {
      // Mock error and verify logging
      // Expected: console.error called with details
    });
  });

  describe('Edge Cases', () => {
    it('handles malformed JSON in request body', async () => {
      // Test with invalid JSON
      // Expected: 400 with JSON parse error
    });

    it('handles very long template_id strings', async () => {
      // Test with extremely long string
      // Expected: 400 with UUID validation error
    });

    it('handles null values in request body', async () => {
      // Test with template_id: null
      // Expected: 400 with validation error
    });
  });
});
```

**Test Coverage Goals**:
- Success Cases: 8 tests
- Validation Errors: 6 tests
- Not Found Cases: 3 tests
- Authorization: 2 tests
- Database Constraints: 2 tests
- Error Handling: 3 tests
- Edge Cases: 3 tests
- **Total: ~27 tests**

### Step 5: Service Tests

**File**: `src/lib/__tests__/promotion.service.spec.ts` (new file or update existing)

```typescript
import { describe, it, expect, beforeEach } from 'vitest';
import { PromotionService } from '../promotion.service';

describe('PromotionService.createPromotion', () => {
  let service: PromotionService;
  let testTemplateId: string;
  let testUserId: string;

  beforeEach(() => {
    // Setup test dependencies
    // Create mock Supabase client
    // Create test fixtures
  });

  describe('Success Cases', () => {
    it('creates promotion with valid template', async () => {
      // Test implementation
    });

    it('copies template fields to promotion', async () => {
      // Verify path, from_level, to_level copied
    });

    it('sets status to draft', async () => {
      // Verify status field
    });

    it('sets created_by to provided userId', async () => {
      // Verify created_by field
    });

    it('sets executed to false', async () => {
      // Verify executed field
    });
  });

  describe('Template Validation', () => {
    it('throws error when template not found', async () => {
      // Test with non-existent template ID
      // Expected: Error thrown with "not found" message
    });

    it('throws error when template is inactive', async () => {
      // Test with inactive template
      // Expected: Error thrown with "not active" message
    });

    it('validates template exists before creating promotion', async () => {
      // Test query order
      // Expected: Template query happens first
    });
  });

  describe('Error Handling', () => {
    it('throws error on database failure', async () => {
      // Mock database error
      // Expected: Error thrown with context
    });

    it('includes template_id in error messages', async () => {
      // Test error message content
      // Expected: template_id included for debugging
    });
  });
});
```

### Step 6: Verify Build and Linting

**Actions**:

1. **Run Linter**:
```bash
pnpm lint
```
**Expected**: No errors

2. **Fix Linting Issues** (if any):
```bash
pnpm lint:fix
```

3. **Run Build**:
```bash
pnpm build
```
**Expected**: Successful build

4. **Type Check**:
```bash
pnpm exec tsc --noEmit
```
**Expected**: No type errors

### Step 7: Performance Testing

**Actions**:

1. **Measure Response Time**:
```bash
curl -w "\nTime: %{time_total}s\n" -s -X POST \
  'http://localhost:3000/api/promotions' \
  -H 'Content-Type: application/json' \
  -d '{"template_id": "750e8400-e29b-41d4-a716-446655440020"}' \
  > /dev/null
```
**Expected**: < 50ms

2. **Monitor Database Query Performance**:
- Check Supabase logs for query execution times
- Template SELECT: ~5-10ms
- Promotion INSERT: ~5-15ms
- Total: ~10-25ms

3. **Test Under Load** (optional):
```bash
# Create multiple promotions rapidly
for i in {1..10}; do
  curl -X POST 'http://localhost:3000/api/promotions' \
    -H 'Content-Type: application/json' \
    -d '{"template_id": "750e8400-e29b-41d4-a716-446655440020"}' &
done
wait
```
**Expected**: All requests succeed, consistent response times

4. **Verify Database Indexes**:
```bash
psql postgresql://postgres:postgres@localhost:54322/postgres \
  -c "SELECT tablename, indexname, indexdef FROM pg_indexes WHERE tablename IN ('promotions', 'promotion_templates') ORDER BY tablename, indexname;"
```
**Expected**: Indexes on primary keys and foreign keys exist

## 10. Future Enhancements

### 1. User Level Validation

**Why**: Ensure user's current level matches template's from_level
**Implementation**: Add user.current_level field, validate before creation
**Business Rule**: User can only apply for promotion from their current level
**Priority**: High (important business rule, deferred for MVP)

### 2. Rate Limiting

**Why**: Prevent abuse (creating excessive promotions)
**Implementation**: Limit promotions per user per time period
**Example**: Max 5 draft promotions per user at any time
**Priority**: Medium (not critical for MVP, low abuse risk)

### 3. Promotion Template Snapshot

**Why**: Preserve exact template state at promotion creation time
**Implementation**: Store full template JSON in promotions table
**Benefit**: Handle template changes without affecting existing promotions
**Priority**: Low (template changes are rare, current approach is sufficient)

### 4. Audit Logging

**Why**: Track who creates promotions and when
**Implementation**: Insert record into audit_logs table
**Event Type**: `promotion.created`
**Payload**: `{ promotion_id, template_id, user_id }`
**Priority**: Medium (useful for analytics and compliance)

### 5. Webhooks/Notifications

**Why**: Notify user when promotion is created
**Implementation**: Trigger webhook or email on creation
**Use Case**: Confirmation email, Slack notification
**Priority**: Low (out of MVP scope per requirements)

### 6. Batch Creation

**Why**: Create multiple promotions at once
**Implementation**: Accept array of template_ids
**Use Case**: User applying for multiple career paths
**Priority**: Very Low (not a common use case)

### 7. Template Caching

**Why**: Reduce database load for template validation
**Implementation**: Cache active templates in Redis/memory
**Benefit**: Faster validation, reduced query load
**Trade-off**: Cache invalidation complexity
**Priority**: Low (premature optimization for MVP)

### 8. Location Header

**Why**: RESTful best practice for resource creation
**Implementation**: Add `Location: /api/promotions/${id}` header
**Benefit**: Client knows where to GET created resource
**Priority**: Low (nice to have, not critical)

---

## Notes & Assumptions

- Authentication is disabled for development and will be implemented later
- Test user ID is fetched from database for development testing
- Template fields (path, from_level, to_level) are denormalized for query performance
- Template validation happens before promotion creation (two queries)
- Status is always 'draft' on creation (enforced by code, not database constraint)
- created_by is always current user ID (cannot be overridden from request body)
- Template not found and inactive template return same 404 response (security)
- Foreign key constraints prevent referencing non-existent templates
- Database handles default values for timestamps and executed field
- UUID validation prevents SQL injection attempts
- Service layer throws errors, route handler maps to HTTP status codes
- Performance is excellent due to simple indexed queries (< 50ms expected)
